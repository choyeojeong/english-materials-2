// api/recommend_ai.ts
export const config = {
  runtime: "edge",
};

type ReqItem = { pair_id: number; en: string; ko?: string };
type Rec = { path: string; reason?: string };

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
};

/** üìö ÌôîÏù¥Ìä∏Î¶¨Ïä§Ìä∏(leaf Ï†ÑÏö© Í≤ΩÎ°úÎì§) */
const TAXONOMY: string[] = [
  "ÌíàÏÇ¨ > ÎåÄÎ™ÖÏÇ¨ > Ïû¨Í∑ÄÎåÄÎ™ÖÏÇ¨",
  "ÌíàÏÇ¨ > ÎåÄÎ™ÖÏÇ¨ > Î∂ÄÏ†ïÎåÄÎ™ÖÏÇ¨",
  "ÌíàÏÇ¨ > ÎèôÏÇ¨ > Íµ¨ÎèôÏÇ¨",
  "ÌíàÏÇ¨ > ÌòïÏö©ÏÇ¨ > ÎπÑÍµêÍ∏â",
  "ÌíàÏÇ¨ > ÌòïÏö©ÏÇ¨ > ÏµúÏÉÅÍ∏â",
  "ÌíàÏÇ¨ > Î∂ÄÏÇ¨ > ÎπàÎèÑÎ∂ÄÏÇ¨",
  "ÌíàÏÇ¨ > Ï†ÑÏπòÏÇ¨ > Ï†ÑÏπòÏÇ¨ Í¥ÄÏö©ÌëúÌòÑ",
  "ÌíàÏÇ¨ > Ï†ëÏÜçÏÇ¨ > Îì±ÏúÑÏ†ëÏÜçÏÇ¨",
  "ÌíàÏÇ¨ > Ï†ëÏÜçÏÇ¨ > Ï¢ÖÏÜçÏ†ëÏÜçÏÇ¨",
  "ÌíàÏÇ¨ > Ï†ëÏÜçÏÇ¨ > ÏÉÅÍ¥ÄÏ†ëÏÜçÏÇ¨",
  "ÌíàÏÇ¨ > Ï†ëÏÜçÏÇ¨ > Ï†ëÏÜçÎ∂ÄÏÇ¨",
  "Î¨∏Ïû•Ïùò ÌòïÏãù > 1ÌòïÏãù",
  "Î¨∏Ïû•Ïùò ÌòïÏãù > 2ÌòïÏãù",
  "Î¨∏Ïû•Ïùò ÌòïÏãù > 3ÌòïÏãù",
  "Î¨∏Ïû•Ïùò ÌòïÏãù > 4ÌòïÏãù",
  "Î¨∏Ïû•Ïùò ÌòïÏãù > 5ÌòïÏãù",
  "Íµ¨(Phrase) > Ï†ÑÏπòÏÇ¨Íµ¨ > ÌòïÏö©ÏÇ¨Íµ¨",
  "Íµ¨(Phrase) > Ï†ÑÏπòÏÇ¨Íµ¨ > Î∂ÄÏÇ¨Íµ¨",
  "Íµ¨(Phrase) > toÎ∂ÄÏ†ïÏÇ¨Íµ¨ > Î™ÖÏÇ¨Ï†Å Ïö©Î≤ï",
  "Íµ¨(Phrase) > toÎ∂ÄÏ†ïÏÇ¨Íµ¨ > ÌòïÏö©ÏÇ¨Ï†Å Ïö©Î≤ï",
  "Íµ¨(Phrase) > toÎ∂ÄÏ†ïÏÇ¨Íµ¨ > Î∂ÄÏÇ¨Ï†Å Ïö©Î≤ï",
  "Íµ¨(Phrase) > ÎèôÎ™ÖÏÇ¨Íµ¨ > Ï£ºÏñ¥ Ïó≠Ìï†",
  "Íµ¨(Phrase) > ÎèôÎ™ÖÏÇ¨Íµ¨ > Î™©Ï†ÅÏñ¥ Ïó≠Ìï†",
  "Íµ¨(Phrase) > ÎèôÎ™ÖÏÇ¨Íµ¨ > Î≥¥Ïñ¥ Ïó≠Ìï†",
  "Íµ¨(Phrase) > ÎèôÎ™ÖÏÇ¨Íµ¨ > Ï†ÑÏπòÏÇ¨Ïùò Î™©Ï†ÅÏñ¥ Ïó≠Ìï†",
  "Íµ¨(Phrase) > ÎèôÎ™ÖÏÇ¨Íµ¨ > Ï†ÑÏπòÏÇ¨ toÏôÄ toÎ∂ÄÏ†ïÏÇ¨Ïùò Íµ¨Î∂Ñ",
  "Íµ¨(Phrase) > Î∂ÑÏÇ¨ > ÌòÑÏû¨Î∂ÑÏÇ¨",
  "Íµ¨(Phrase) > Î∂ÑÏÇ¨ > Í≥ºÍ±∞Î∂ÑÏÇ¨",
  "Íµ¨(Phrase) > Î∂ÑÏÇ¨ > Î∂ÑÏÇ¨Íµ¨Î¨∏",
  "Íµ¨(Phrase) > Î∂ÑÏÇ¨ > ÎèÖÎ¶ΩÎ∂ÑÏÇ¨Íµ¨Î¨∏",
  "Íµ¨(Phrase) > Î∂ÑÏÇ¨ > with A B",
  "Íµ¨(Phrase) > ÎèôÍ≤©Íµ¨",
  "Íµ¨(Phrase) > Î≥ëÎ†¨Íµ¨",
  "Ï†à(Clause) > Î™ÖÏÇ¨Ï†à > thatÏ†à",
  "Ï†à(Clause) > Î™ÖÏÇ¨Ï†à > whetherÏ†à (ifÏ†à)",
  "Ï†à(Clause) > Î™ÖÏÇ¨Ï†à > ÏùòÎ¨∏ÏÇ¨Ï†à",
  "Ï†à(Clause) > ÌòïÏö©ÏÇ¨Ï†à > Í¥ÄÍ≥ÑÎåÄÎ™ÖÏÇ¨Ï†à",
  "Ï†à(Clause) > ÌòïÏö©ÏÇ¨Ï†à > Í¥ÄÍ≥ÑÎ∂ÄÏÇ¨Ï†à",
  "Ï†à(Clause) > Î∂ÄÏÇ¨Ï†à > ÏãúÍ∞ÑÏùò Î∂ÄÏÇ¨Ï†à",
  "Ï†à(Clause) > Î∂ÄÏÇ¨Ï†à > Ï°∞Í±¥Ïùò Î∂ÄÏÇ¨Ï†à",
  "Ï†à(Clause) > Î∂ÄÏÇ¨Ï†à > Ïù¥Ïú†Ïùò Î∂ÄÏÇ¨Ï†à",
  "Ï†à(Clause) > Î∂ÄÏÇ¨Ï†à > ÏñëÎ≥¥Ïùò Î∂ÄÏÇ¨Ï†à",
  "Ï†à(Clause) > Î∂ÄÏÇ¨Ï†à > Í≤∞Í≥ºÏùò Î∂ÄÏÇ¨Ï†à",
  "Ï†à(Clause) > Î∂ÄÏÇ¨Ï†à > Î™©Ï†ÅÏùò Î∂ÄÏÇ¨Ï†à",
  "Ï†à(Clause) > ÎèôÍ≤©Ï†à",
  "Ï†à(Clause) > Í∞êÌÉÑÎ¨∏",
  "Ï†à(Clause) > Î™ÖÎ†πÎ¨∏",
  "ÌäπÏàò Íµ¨Î¨∏ > ÎπÑÍµêÍ∏â Íµ¨Î¨∏",
  "ÌäπÏàò Íµ¨Î¨∏ > Í∞ïÏ°∞ Íµ¨Î¨∏ > It is ~ that Í∞ïÏ°∞Íµ¨Î¨∏",
  "ÌäπÏàò Íµ¨Î¨∏ > Í∞ïÏ°∞ Íµ¨Î¨∏ > ÎèôÏÇ¨ Í∞ïÏ°∞",
  "ÌäπÏàò Íµ¨Î¨∏ > ÎèÑÏπò Íµ¨Î¨∏",
  "ÌäπÏàò Íµ¨Î¨∏ > Í∞ÄÏ†ïÎ≤ï Íµ¨Î¨∏ > Í∞ÄÏ†ïÎ≤ï Í≥ºÍ±∞",
  "ÌäπÏàò Íµ¨Î¨∏ > Í∞ÄÏ†ïÎ≤ï Íµ¨Î¨∏ > Í∞ÄÏ†ïÎ≤ï Í≥ºÍ±∞ÏôÑÎ£å",
  "ÌäπÏàò Íµ¨Î¨∏ > Í∞ÄÏ†ïÎ≤ï Íµ¨Î¨∏ > ÌòºÌï© Í∞ÄÏ†ïÎ≤ï",
  "ÌäπÏàò Íµ¨Î¨∏ > Í∞ÄÏ†ïÎ≤ï Íµ¨Î¨∏ > as if Í∞ÄÏ†ïÎ≤ï",
  "ÌäπÏàò Íµ¨Î¨∏ > Í∞ÄÏ†ïÎ≤ï Íµ¨Î¨∏ > I wish Í∞ÄÏ†ïÎ≤ï",
  "ÌäπÏàò Íµ¨Î¨∏ > ÏàòÎèôÌÉú Íµ¨Î¨∏ > 3ÌòïÏãù ÏàòÎèôÌÉú",
  "ÌäπÏàò Íµ¨Î¨∏ > ÏàòÎèôÌÉú Íµ¨Î¨∏ > 4ÌòïÏãù ÏàòÎèôÌÉú",
  "ÌäπÏàò Íµ¨Î¨∏ > ÏàòÎèôÌÉú Íµ¨Î¨∏ > 5ÌòïÏãù ÏàòÎèôÌÉú",
  "ÌäπÏàò Íµ¨Î¨∏ > ÏÉùÎûµ Íµ¨Î¨∏",
];

const MIN_REC = 3;
const MAX_REC = 6;
const OPENAI_MODEL = "gpt-4o-mini";
const OPENAI_TIMEOUT_MS = 1000 * 12;
const RETRY_THRESHOLD = 2;

const SYS_PROMPT = `
ÎÑàÎäî ÌïúÍµ≠ Ï§ë¬∑Í≥†Îì± ÏòÅÏñ¥ ÍµêÏú°Í≥ºÏ†ï Î∂ÑÎ•ò Î≥¥Ï°∞ ÍµêÏÇ¨Îã§.

Î™©Ìëú:
- ÏûÖÎ†•Îêú EN/KO Î¨∏Ïû•ÏùÑ Î≥¥Í≥† ÍµêÏú°Ï†ÅÏúºÎ°ú ÌïµÏã¨Ï†ÅÏù∏ Î¨∏Î≤ï¬∑Íµ¨Î¨∏ Ìè¨Ïù∏Ìä∏Î•º **ÏµúÏÜå 3Í∞ú, ÏµúÎåÄ 6Í∞ú** Ï∂îÏ≤úÌïúÎã§.
- Îã®, Ï†ïÎßê ÌôïÏã†Ïù¥ ÏóÜÏúºÎ©¥ **Îπà Î∞∞Ïó¥([])** ÏùÑ Î∞òÌôòÌïúÎã§.

Í∑úÏπô:
- Ï∂îÏ≤ú Í≤ΩÎ°úÎäî ÏïÑÎûò 'ÌóàÏö© Í≤ΩÎ°ú(ÌôîÏù¥Ìä∏Î¶¨Ïä§Ìä∏)' ÎÇ¥Ïùò **Î¶¨ÌîÑ Í≤ΩÎ°úÎßå** ÏÇ¨Ïö©ÌïúÎã§.
- Í≤ΩÎ°ú Î¨∏ÏûêÏó¥ÏùÄ **Í≥µÎ∞±, Í¥ÑÌò∏, Í∏∞Ìò∏ÍπåÏßÄ Ìïú Í∏ÄÏûêÎèÑ Îã§Î•¥Í≤å Ïì∞ÏßÄ Îßê Í≤É**.
- Í≤ΩÎ°ú Íµ¨Î∂ÑÏûêÎäî Ìï≠ÏÉÅ **" > "** (ÏñëÏ™Ω Ìïú Ïπ∏ Í≥µÎ∞± Ìè¨Ìï®)Îßå ÏÇ¨Ïö©.
- **ÎèôÏùº/Ïú†ÏÇ¨ ÏùòÎØ∏ Ï§ëÎ≥µÏùÑ ÌîºÌïòÍ≥† Îã§ÏñëÌïòÍ≤å** Ï†úÏïàÌïúÎã§.
- EN Î¨∏Ïû• ÏùòÎØ∏Î•º Ïö∞ÏÑ†ÏúºÎ°ú ÌåêÎã®ÌïòÍ≥†, KOÎäî Î≥¥Ï°∞Ï†ÅÏúºÎ°úÎßå ÏÇ¨Ïö©.
- Ï∂úÎ†•ÏùÄ Ïò§ÏßÅ JSON(Í≥†Ï†ï Ïä§ÌÇ§Îßà)Î°úÎßå.

ÌóàÏö© Í≤ΩÎ°ú Î™©Î°ù:
${TAXONOMY.map((p) => `- ${p}`).join("\n")}
`.trim();

const FEW_SHOT: Array<{ en: string; ko: string; paths: string[] }> = [
  {
    en: "I wish I could fly.",
    ko: "ÎÇòÎäî ÎÇ† Ïàò ÏûàÏúºÎ©¥ Ï¢ãÍ≤†Îã§.",
    paths: [
      "ÌäπÏàò Íµ¨Î¨∏ > Í∞ÄÏ†ïÎ≤ï Íµ¨Î¨∏ > I wish Í∞ÄÏ†ïÎ≤ï",
      "Î¨∏Ïû•Ïùò ÌòïÏãù > 3ÌòïÏãù",
      "Ï†à(Clause) > Î™ÖÏÇ¨Ï†à > thatÏ†à",
    ],
  },
  {
    en: "To live a happy life, you need to be grateful.",
    ko: "ÌñâÎ≥µÌïòÍ≤å ÏÇ¥Í∏∞ ÏúÑÌï¥ÏÑúÎäî Í∞êÏÇ¨Ìï† Ï§Ñ ÏïåÏïÑÏïº ÌïúÎã§.",
    paths: [
      "Íµ¨(Phrase) > toÎ∂ÄÏ†ïÏÇ¨Íµ¨ > Î∂ÄÏÇ¨Ï†Å Ïö©Î≤ï",
      "Î¨∏Ïû•Ïùò ÌòïÏãù > 1ÌòïÏãù",
      "ÌíàÏÇ¨ > ÌòïÏö©ÏÇ¨ > ÎπÑÍµêÍ∏â",
    ],
  },
];

const allow = new Set(TAXONOMY);

function filterToAllowed(items: Rec[], max = MAX_REC): Rec[] {
  const out: Rec[] = [];
  for (const it of items ?? []) {
    const path = String(it?.path ?? "").replace(/\s+/g, " ").trim();
    if (!path) continue;
    if (allow.has(path) && !out.find((x) => x.path === path)) {
      out.push({ path, reason: (it?.reason ?? "").toString().slice(0, 160) });
    }
    if (out.length >= max) break;
  }
  return out;
}

function buildUserContent(en: string, ko?: string, pass: 1 | 2 = 1) {
  const lines = [
    `EN Ïö∞ÏÑ†ÏúºÎ°ú ÌåêÎã®ÌïòÍ≥†, KOÎäî Î≥¥Ï°∞Ï†ÅÏúºÎ°úÎßå ÏÇ¨Ïö©.`,
    `Í∂åÏû• Í∞úÏàò: ${MIN_REC}~${MAX_REC}Í∞ú.`,
    pass === 1
      ? `ÌôïÏã† ÏóÜÏúºÎ©¥ Îπà Î∞∞Ïó¥([]) ÌóàÏö©.`
      : `Í∞ÄÎä•ÌïòÎ©¥ Îπà Î∞∞Ïó¥ ÎåÄÏã†, Í∞ÄÏû• Ï†ÅÏ†àÌïú Î¶¨ÌîÑ Í≤ΩÎ°úÎì§ÏùÑ ${MIN_REC}~${MAX_REC}Í∞ú Ï†úÏãú.`,
    `Í≤ΩÎ°ú Íµ¨Î∂ÑÏûêÎäî " > "Î•º ÏÇ¨Ïö©ÌïòÍ≥†, ÌôîÏù¥Ìä∏Î¶¨Ïä§Ìä∏Ïóê **Ï†ïÌôïÌûà ÏùºÏπò**Ìï¥Ïïº Ìï®.`,
    `Ï§ëÎ≥µ/Ïú†ÏÇ¨ Ìè¨Ïù∏Ìä∏Îäî ÌîºÌïòÍ≥† **Îã§ÏñëÏÑ±**ÏùÑ ÌôïÎ≥¥Ìï† Í≤É.`,
  ];
  const rows = [`ÏòÅÎ¨∏: ${en}`, `ÌïúÍ∏Ä: ${ko ? ko : "(ÏóÜÏùå)"}`].join("\n");

  const shot = FEW_SHOT.map((s) =>
    [
      `ÏòàÏãú Î¨∏Ïû•: ${s.en}`,
      `ÏòàÏãú Î≤àÏó≠: ${s.ko}`,
      `ÏòàÏãú Ï†ïÎãµ(JSON): ${JSON.stringify({
        items: s.paths.map((p) => ({ path: p, reason: "ÌïµÏã¨ Ìè¨Ïù∏Ìä∏" })),
      })}`,
    ].join("\n"),
  ).join("\n\n");

  return `${lines.join("\n")}\n\n${rows}\n\n${shot}`;
}

function safeParseArrayOrItems(jsonText: string): Rec[] {
  try {
    const obj: unknown = JSON.parse(jsonText);
    if (Array.isArray(obj) && obj.every(o => o && typeof o.path === "string")) return obj as Rec[];
    if (typeof obj === "object" && obj && Array.isArray((obj as any).items)) return (obj as any).items as Rec[];
  } catch {}
  const m =
    jsonText.match(/```json\s*([\s\S]*?)\s*```/) ??
    jsonText.match(/(\{[\s\S]*\}|\[[\s\S]*\])/);
  if (m) {
    try {
      const obj2: unknown = JSON.parse(m[1]);
      if (Array.isArray(obj2) && obj2.every(o => o && typeof (o as any).path === "string")) return obj2 as Rec[];
      if (typeof obj2 === "object" && obj2 && Array.isArray((obj2 as any).items)) return (obj2 as any).items as Rec[];
    } catch {}
  }
  return [];
}

async function callOpenAI(payload: Record<string, unknown>, timeoutMs = OPENAI_TIMEOUT_MS): Promise<any> {
  const apiKey = process.env.OPENAI_API_KEY;
  if (!apiKey) throw new Error("OPENAI_API_KEY not set on Vercel");

  const ac = new AbortController();
  const t = setTimeout(() => ac.abort(), timeoutMs);
  try {
    const r = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify(payload),
      signal: ac.signal,
    });
    if (!r.ok) throw new Error(`OpenAI HTTP ${r.status}: ${await r.text()}`);
    return await r.json();
  } finally {
    clearTimeout(t);
  }
}

function schemaDef() {
  return {
    type: "json_schema",
    json_schema: {
      name: "CategoryRecommendation",
      schema: {
        type: "object",
        properties: {
          items: {
            type: "array",
            maxItems: MAX_REC, // Îπà Î∞∞Ïó¥ ÌóàÏö©
            items: {
              type: "object",
              required: ["path", "reason"],
              properties: {
                path: { type: "string", enum: TAXONOMY }, // ÌôîÏù¥Ìä∏Î¶¨Ïä§Ìä∏ Í∞ïÏ†ú
                reason: { type: "string", minLength: 2, maxLength: 160 },
              },
              additionalProperties: false,
            },
          },
        },
        required: ["items"],
        additionalProperties: false,
      },
      strict: true,
    },
  } as const;
}

async function askOnce(en: string, ko: string | undefined, pass: 1 | 2, temperature: number): Promise<Rec[]> {
  const data = await callOpenAI({
    model: OPENAI_MODEL,
    temperature,
    max_tokens: 500,
    response_format: schemaDef(),
    messages: [
      { role: "system", content: SYS_PROMPT },
      { role: "user", content: buildUserContent(en, ko, pass) },
    ],
  });

  const text = data?.choices?.[0]?.message?.content ?? "";
  const arr = safeParseArrayOrItems(text);
  return filterToAllowed(arr);
}

function heuristic(en: string): Rec[] {
  const s = (en || "").toLowerCase();
  const picks: string[] = [];
  if (s.includes("i wish")) picks.push("ÌäπÏàò Íµ¨Î¨∏ > Í∞ÄÏ†ïÎ≤ï Íµ¨Î¨∏ > I wish Í∞ÄÏ†ïÎ≤ï");
  if (/\b(if|unless|provided|as long as)\b/.test(s)) picks.push("Ï†à(Clause) > Î∂ÄÏÇ¨Ï†à > Ï°∞Í±¥Ïùò Î∂ÄÏÇ¨Ï†à");
  if (/\b(because|since|as)\b/.test(s)) picks.push("Ï†à(Clause) > Î∂ÄÏÇ¨Ï†à > Ïù¥Ïú†Ïùò Î∂ÄÏÇ¨Ï†à");
  if (/\b(when|while|after|before|until|once)\b/.test(s)) picks.push("Ï†à(Clause) > Î∂ÄÏÇ¨Ï†à > ÏãúÍ∞ÑÏùò Î∂ÄÏÇ¨Ï†à");
  if (/\b(though|although|even though|even if|whereas)\b/.test(s)) picks.push("Ï†à(Clause) > Î∂ÄÏÇ¨Ï†à > ÏñëÎ≥¥Ïùò Î∂ÄÏÇ¨Ï†à");
  if (/\bthat\b/.test(s)) picks.push("Ï†à(Clause) > Î™ÖÏÇ¨Ï†à > thatÏ†à");
  if (/\b(who|which|that)\b/.test(s)) picks.push("Ï†à(Clause) > ÌòïÏö©ÏÇ¨Ï†à > Í¥ÄÍ≥ÑÎåÄÎ™ÖÏÇ¨Ï†à");
  if (/\b(where|in which|at which|on which|to which)\b/.test(s)) picks.push("Ï†à(Clause) > ÌòïÏö©ÏÇ¨Ï†à > Í¥ÄÍ≥ÑÎ∂ÄÏÇ¨Ï†à");
  if (/\bto\s+\w+/.test(s)) picks.push("Íµ¨(Phrase) > toÎ∂ÄÏ†ïÏÇ¨Íµ¨ > Î∂ÄÏÇ¨Ï†Å Ïö©Î≤ï");
  if (/\b(more|most|less|least|than|as\b.*\bas)\b/.test(s)) picks.push("ÌäπÏàò Íµ¨Î¨∏ > ÎπÑÍµêÍ∏â Íµ¨Î¨∏");

  const uniq = Array.from(new Set(picks)).filter(p => allow.has(p)).slice(0, MAX_REC);
  return uniq.map(p => ({ path: p, reason: "Ï†ÑÌòïÏ†Å Ìå®ÌÑ¥(Ìú¥Î¶¨Ïä§Ìã±)" }));
}

async function recommendForSentence(en: string, ko?: string): Promise<Rec[]> {
  try {
    // 1Ï∞®: Î≥¥ÏàòÏ†Å (Îπà Î∞∞Ïó¥ ÌóàÏö©)
    let recs = await askOnce(en, ko, 1, 0.7);

    // 2Ï∞®: ÎÑàÎ¨¥ Ï†ÅÏúºÎ©¥ Ï†ÅÍ∑πÏ†ÅÏúºÎ°ú Ïû¨ÏöîÏ≤≠
    if (recs.length <= RETRY_THRESHOLD) {
      const more = await askOnce(en, ko, 2, 0.9);
      recs = filterToAllowed([...recs, ...more]);
    }

    // Ìú¥Î¶¨Ïä§Ìã± Î≥¥Í∞ï
    if (recs.length < MIN_REC) {
      recs = filterToAllowed([...recs, ...heuristic(en)]);
    }
    return recs;
  } catch (e) {
    // OpenAI Ïã§Ìå® ÏãúÏóêÎèÑ ÏµúÏÜåÌïúÏùò Í≤∞Í≥º Î≥¥Ïû•
    return heuristic(en);
  }
}

export default async function handler(req: Request) {
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }
  if (req.method !== "POST") {
    return new Response("POST only", { status: 405, headers: corsHeaders });
  }
  try {
    const body = await req.json();
    const items: ReqItem[] = Array.isArray(body?.items) ? body.items : [];
    const results = await Promise.all(
      items.map(async (it) => ({
        pair_id: it.pair_id,
        recs: await recommendForSentence(it.en, it.ko),
      })),
    );
    return new Response(JSON.stringify({ results }), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  } catch (e: any) {
    return new Response(JSON.stringify({ error: e?.message || String(e) }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }
}
